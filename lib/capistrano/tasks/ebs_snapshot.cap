namespace :deploy do

  task :snapshot do
    on primary(:app) do
      upload! File.expand_path('../../../../bin/snapshot.py', __FILE__), './snapshot.py'
      execute "BOTO_CONFIG=~/.boto ~/snapshot.py -t app_#{fetch(:application)}"
    end
  end
end

namespace :autoscale do

  task :aws_credentials do
    credential_file = fetch(:aws_credential_file, ENV['AWS_CREDENTIAL_FILE'])

    fetch(:aws_access_key_id) { -> { ENV['AWS_ACCESS_KEY_ID'] || Capistrano::Ec2tag.read_from_credential_file('AWSAccessKeyId', credential_file) } }

    fetch(:aws_secret_access_key) { -> { ENV['AWS_SECRET_ACCESS_KEY'] || Capistrano::Ec2tag.read_from_credential_file('AWSSecretKey', credential_file) } }

    fetch(:ec2) { -> { @ec2 ||= AWS::EC2.new({access_key_id: fetch(:aws_access_key_id), secret_access_key: fetch(:aws_secret_access_key), region: fetch(:aws_region, 'us-east-1')}.merge! fetch(:aws_params, {})) } }
    fetch(:auto_scaling) { -> { @auto_scaling ||= AWS::AutoScaling.new({access_key_id: fetch(:aws_access_key_id), secret_access_key: fetch(:aws_secret_access_key), region: fetch(:aws_region, 'us-east-1')}.merge! fetch(:aws_params, {})) } }
  end

  task :setup_ami do

    run_locally do
      unless roles(:stub).empty?
        info 'Stub instance already exists'
        return
      end
      info "starting"

      info "creating image"
      instance = fetch(:primary_instance)
      image_name = "#{fetch(:application)}-image-for-autoscale"
      old_image_names = []
      fetch(:ec2).images.filter('name', image_name + '*').each { |i| old_image_names << i.name }
      if old_image_names != nil
        last_idx = old_image_names.map { |s| s[/#{image_name}\-?(.*)/, 1].to_i(16) }.max
        image_name = "#{image_name}-#{(last_idx+1).to_s(16)}"
      end
      image = instance.create_image(image_name, description: 'auto generated by ebs-autoscale', no_reboot: true)
      info "creating image #{image.id} for #{instance.id}..."
      image.add_tag('Name', value: "ami-for-#{fetch(:application)}")
      while image.state == :pending
        sleep(10)
      end
      info "image state: #{image.state}"
      new_instance_data = {
          availability_zone: instance.availability_zone,
          key_name: instance.key_name,
          security_group_ids: instance.security_groups.map(&:id),
          instance_type: 't1.micro',
          subnet: instance.subnet,
          block_device_mappings: [{no_device: '', device_name: '/dev/sdf'}],
          associate_public_ip_address: true
      }
      info "image created, creating stub instance - #{new_instance_data}"
      new_instance = image.run_instance new_instance_data
      new_instance.add_tag('Name', value: "#{fetch(:application)}-stub-instance")
      new_instance.add_tag('deploy', value: fetch(:stub_deploy_tag))
    end
  end

  task :update_ami do
    run_locally do
      instance = nil
      fetch(:ec2).instances.filter('ip-address', primary(:stub).to_s).each do |inst|
        instance ||= inst
      end
      image_name = "#{fetch(:application)}-image-for-autoscale"
      old_image_names = []
      fetch(:ec2).images.filter('name', image_name + '*').each { |i| old_image_names << i.name }
      if old_image_names != nil
        last_idx = old_image_names.map { |s| s[/#{image_name}\-?(.*)/, 1].to_i(16) }.max
        image_name = "#{image_name}-#{(last_idx+1).to_s(16)}"
      end
      image = instance.create_image(image_name, description: 'auto generated by ebs-autoscale', no_reboot: true)
      info "creating image #{image.id} for #{instance.id}..."
      image.add_tag('Name', value: "ami-for-#{fetch(:application)}")
    end
  end

  task :fetch_primary_instance do
    fetch(:primary_instance) { -> {
      instance = nil
      fetch(:ec2).instances.filter('ip-address', primary(:app).to_s).each do |inst|
        instance ||= inst
      end
      instance
    } }
  end

  task :setup_launch_configuration do
    run_locally do
      images = []
      fetch(:ec2).images.tagged('Name').tagged_values("ami-for-#{fetch(:application)}").each { |i| images << i }
      image = images.max_by(&:name)
      info "setting launch configuration with ami #{image.name}"
      instance = fetch(:primary_instance)
      new_instance_data = {
          availability_zone: instance.availability_zone,
          key_pair: instance.key_pair,
          security_groups: [*instance.security_groups],
          subnet: instance.subnet,
         # block_device_mappings: [{no_device: '', device_name: '/dev/sdf'}],
          associate_public_ip_address: true,
          iam_instance_profile: fetch(:iam_role),
          user_data: <<USERDATA
#!/bin/bash
/home/ubuntu/userdata.sh #{fetch(:application)} #{fetch(:application)}-instance #{fetch(:app_deploy_tag)}
USERDATA
      }

      fetch(:auto_scaling).launch_configurations.create("#{fetch(:application)}", image.id, instance.instance_type, new_instance_data)
    end
  end

  task :setup_scaling_group do
    instance = fetch(:primary_instance)
    fetch(:auto_scaling).groups.create(fetch(:application),
                                       launch_configuration: fetch(:application),
                                       min_size: fetch(:auto_scale_min_size, 2),
                                       max_size: fetch(:auto_scale_max_size, 6),
                                       subnets: [*instance.subnet],
                                       load_balancers: fetch(:load_balancers)
    )
  end

  before :fetch_primary_instance, :aws_credentials

  before :update_ami, :aws_credentials, :prepare_stub do
    on roles(:stub) do
      upload! File.expand_path('../../../../bin/userdata.sh', __FILE__), './userdata.sh'
      upload! File.expand_path('../../../../bin/prep_instance.py', __FILE__), './prep_instance.py'
    end
  end

  before :setup_scaling_group, :fetch_primary_instance

  before :setup_launch_configuration, :fetch_primary_instance

  before :setup_ami, :fetch_primary_instance, :prepare_primary do
    on primary(:app) do
      if roles(:stub).empty?
        info "uploading"
        upload! File.expand_path('../../../../bin/userdata.sh', __FILE__), './userdata.sh'
        upload! File.expand_path('../../../../bin/prep_instance.py', __FILE__), './prep_instance.py'

        execute "mv #{deploy_path} #{deploy_path}.static"

        info "done uploading"
      else
        info 'Stub instance already exists'
      end
    end
  end

  after :setup_ami, :revert_primary do
    on primary(:app) do
      unless roles(:stub).empty?
        info 'Stub instance already exists'
        return
      end
      info "reverting"
      execute "mv #{deploy_path}.static #{deploy_path}"
      info "done"
    end
  end

end

after :deploy, "deploy:snapshot"