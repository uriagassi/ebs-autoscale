namespace :deploy do

  task :snapshot do
    on primary(:app) do
      upload! File.expand_path('../../../../bin/snapshot.py', __FILE__), './snapshot.py'
      execute "BOTO_CONFIG=~/.boto ~/snapshot.py -t app_#{fetch(:application)}"
    end
  end
end

def get_next_name(image_name, old_image_names)
  if old_image_names != nil
    last_idx = old_image_names.map { |s| s[/#{image_name}\-?(.*)/, 1].to_i(16) }.max || 0
    image_name = "#{image_name}-#{(last_idx+1).to_s(16)}"
  end
  image_name
end

def get_names_from_repository(base_name, repository)
  existing_names = {}
  repository.each_batch do |batch|
    existing_names.merge! Hash[batch.map{|i| [i.name, i]}.select { |name, i| name[/^#{base_name}/] }]
  end
  existing_names
end

def get_next_name_from_repository(base_name, repository)
  existing_names = get_names_from_repository(base_name, repository)
  [get_next_name(base_name, existing_names.keys), (existing_names.max_by { |k,_| k } || []).last ]
end

namespace :autoscale do

  task :aws_credentials do
    credential_file = fetch(:aws_credential_file, ENV['AWS_CREDENTIAL_FILE'])

    fetch(:aws_access_key_id) { -> { ENV['AWS_ACCESS_KEY_ID'] || Capistrano::Ec2tag.read_from_credential_file('AWSAccessKeyId', credential_file) } }

    fetch(:aws_secret_access_key) { -> { ENV['AWS_SECRET_ACCESS_KEY'] || Capistrano::Ec2tag.read_from_credential_file('AWSSecretKey', credential_file) } }

    fetch(:ec2) { -> { @ec2 ||= AWS::EC2.new({access_key_id: fetch(:aws_access_key_id), secret_access_key: fetch(:aws_secret_access_key), region: fetch(:aws_region, 'us-east-1')}.merge! fetch(:aws_params, {})) } }
    fetch(:auto_scaling) { -> { @auto_scaling ||= AWS::AutoScaling.new({access_key_id: fetch(:aws_access_key_id), secret_access_key: fetch(:aws_secret_access_key), region: fetch(:aws_region, 'us-east-1')}.merge! fetch(:aws_params, {})) } }
  end

  task :setup_ami do

    run_locally do
      unless roles(:stub).empty?
        info 'Stub instance already exists'
        return
      end
      info "starting"

      info "creating image"
      instance = fetch(:primary_instance)
      image_name = "#{fetch(:application)}-image-for-autoscale"
      old_image_names = []
      fetch(:ec2).images.filter('name', image_name + '*').each { |i| old_image_names << i.name }
      image_name = get_next_name(image_name, old_image_names)
      image = instance.create_image(image_name, description: 'auto generated by ebs-autoscale', no_reboot: true)
      info "creating image #{image.id} for #{instance.id}..."
      image.add_tag('Name', value: "ami-for-#{fetch(:application)}")
      while image.state == :pending
        sleep(10)
      end
      info "image state: #{image.state}"
      new_instance_data = {
          availability_zone: instance.availability_zone,
          key_name: instance.key_name,
          security_group_ids: instance.security_groups.map(&:id),
          instance_type: 't1.micro',
          subnet: instance.subnet,
          block_device_mappings: [{no_device: '', device_name: '/dev/sdf'}],
          associate_public_ip_address: true
      }
      info "image created, creating stub instance - #{new_instance_data}"
      new_instance = image.run_instance new_instance_data
      new_instance.add_tag('Name', value: "#{fetch(:application)}-stub-instance")
      new_instance.add_tag('deploy', value: fetch(:stub_deploy_tag))
    end
  end

  task :setup_ebs do
    on primary(:app) do
      instance_tags = %Q["{\\"Name\\":\\"#{fetch(:application)}-instance\\",\\"deploy\\":\\"#{fetch(:app_deploy_tag)}\\"}"]
      execute "BOTO_CONFIG=~/.boto ~/prep_instance.py -g #{instance_tags} -t app_#{fetch(:application)} -N"
    end
  end

  task :update_ami do
    run_locally do
      instance = nil
      fetch(:ec2).instances.filter('ip-address', primary(:stub).to_s).each do |inst|
        instance ||= inst
      end
      image_name = "#{fetch(:application)}-image-for-autoscale"
      old_image_names = []
      fetch(:ec2).images.filter('name', image_name + '*').each { |i| old_image_names << i.name }
      image_name = get_next_name(image_name, old_image_names)
      image = instance.create_image(image_name, description: 'auto generated by ebs-autoscale', no_reboot: true)
      info "creating image #{image.id} for #{instance.id}..."
      image.add_tag('Name', value: "ami-for-#{fetch(:application)}")
    end
  end

  task :fetch_primary_instance do
    fetch(:primary_instance) { -> {
      instance = nil
      fetch(:ec2).instances.filter('ip-address', primary(:app).to_s).each do |inst|
        instance ||= inst
      end
      instance
    } }
  end

  task :setup_launch_configuration do
    run_locally do
      images = []
      fetch(:ec2).images.tagged('Name').tagged_values("ami-for-#{fetch(:application)}").each { |i| images << i }
      image = images.max_by(&:name)
      info "setting launch configuration with ami #{image.name}"
      instance = fetch(:primary_instance)
      new_instance_data = {
          availability_zone: fetch(:as_availability_zone, instance.availability_zone),
          key_pair: fetch(:as_key_pair, instance.key_pair),
          security_groups: [*fetch(:as_security_groups, instance.security_groups)],
          subnet: fetch(:as_subnet, instance.subnet),
         # block_device_mappings: [{no_device: '', device_name: '/dev/sdf'}],
          associate_public_ip_address: true,
          iam_instance_profile: fetch(:iam_role),
          user_data: <<USERDATA
#!/bin/bash -ex
exec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1
/home/ubuntu/userdata.sh #{fetch(:application)} #{fetch(:application)}-instance #{fetch(:app_deploy_tag)}
#{fetch(:as_startup_script)}
USERDATA
      }
      name, _ = get_next_name_from_repository(fetch(:application), fetch(:auto_scaling).launch_configurations)
      fetch(:auto_scaling).launch_configurations.create(name, image.id, fetch(:as_instance_type, instance.instance_type), new_instance_data)
    end
  end

  task :setup_scaling_group do
    run_locally do
      instance = fetch(:primary_instance)
      name, last = get_next_name_from_repository(fetch(:application), fetch(:auto_scaling).groups)
      launch_configuration = get_names_from_repository(fetch(:application), fetch(:auto_scaling).launch_configurations).keys.max
      new_group = fetch(:auto_scaling).groups.create(name,
                                                     launch_configuration: launch_configuration,
                                                     min_size: fetch(:auto_scale_min_size, 2),
                                                     max_size: fetch(:auto_scale_max_size, 6),
                                                     subnets: [*fetch(:as_subnet, instance.subnet)],
                                                     load_balancers: fetch(:load_balancers)
      )
      if last
        @cloud_watch ||= AWS::CloudWatch.new({access_key_id: fetch(:aws_access_key_id), secret_access_key: fetch(:aws_secret_access_key), region: fetch(:aws_region, 'us-east-1')}.merge! fetch(:aws_params, {}))
        last.scaling_policies.each do |policy|
          props = Hash[%i(adjustment_type scaling_adjustment cooldown min_adjustment_step).map { |s| [s, policy.send(s)] }.reject { |_, v| v.nil? }]
          new_group.scaling_policies[policy.name].put(props)
          policy.alarms.each do |k|
            alarm = @cloud_watch.alarms[k]
            alarm_props = Hash[%i(namespace metric_name comparison_operator evaluation_periods period statistic threshold insufficient_data_actions ok_actions actions_enabled alarm_actions alarm_description unit).map { |s| [s, alarm.send(s)] }.reject { |_, v| v.nil? }]
            (alarm_props[:alarm_actions] ||= []) << new_group.scaling_policies[policy.name].arn
            alarm.update(alarm_props)
          end
        end
      end
    end
  end

  before :fetch_primary_instance, :aws_credentials

  task :prepare_stub do
    on roles(:stub) do
      upload! File.expand_path('../../../../bin/userdata.sh', __FILE__), './userdata.sh'
      upload! File.expand_path('../../../../bin/prep_instance.py', __FILE__), './prep_instance.py'
    end
  end

  before :update_ami, :prepare_stub

  before :update_ami, :aws_credentials

  before :setup_scaling_group, :fetch_primary_instance

  before :setup_launch_configuration, :fetch_primary_instance

  task :validate_stub_instance do
    fail 'stub already exists' unless roles(:stub).empty?
  end

  task :prepare_primary do
    on primary(:app) do
        info "uploading"
        upload! File.expand_path('../../../../bin/userdata.sh', __FILE__), './userdata.sh'
        upload! File.expand_path('../../../../bin/prep_instance.py', __FILE__), './prep_instance.py'

        execute "mv #{deploy_path} #{deploy_path}.static"

        info "done uploading"
    end
  end

  before :setup_ami, :validate_stub_instance
  before :setup_ami, :prepare_primary

  before :setup_ami, :fetch_primary_instance

  task :revert_primary do
    on primary(:app) do
      info "reverting"
      execute "mv #{deploy_path}.static #{deploy_path}"
      info "done"
    end
  end

  after :setup_ami, 'autoscale:revert_primary'

  before :setup_ebs, :prepare_primary
  after :setup_ebs, 'autoscale:revert_primary', 'deploy:snapshot'

end

after 'deploy:finishing', "deploy:snapshot"